---
layout: default
title: "Правила поєдинків"
---

# SQL Judo. Правила поєдинків

## Вивчайте структуру даних

> *«Той, хто бачить зерно, не загубить поле.»*

Починайте із вивчення структури таблиць, типів полів та індексів.

```sql
sp_help 'dbo.YourTable'
```

[sp_help (Transact-SQL) - SQL Server | Microsoft Learn](https://learn.microsoft.com/en-us/sql/relational-databases/system-stored-procedures/sp-help-transact-sql?view=sql-server-ver17)

```sql
SELECT * 
FROM sys.dm_exec_describe_first_result_set(
  N'SELECT 
    CustomerID, 
    TerritoryID, 
    AccountNumber 
  FROM Sales.Customer 
  WHERE CustomerID = @CustomerID;',  
  N'@CustomerID int', 
  0
) a;  
```
```sql
SELECT *
FROM sys.dm_exec_describe_first_result_set (N'SELECT * FROM dbo.YourTable', NULL, 0);
```
[dm_exec_describe_first_result_set - SQL Server | Microsoft Learn](https://learn.microsoft.com/sql/relational-databases/system-dynamic-management-views/sys-dm-exec-describe-first-result-set-transact-sql?view=sql-server-ver17)

[sp_describe_first_result_set - SQL Server | Microsoft Learn](https://learn.microsoft.com/sql/relational-databases/system-stored-procedures/sp-describe-first-result-set-transact-sql?view=sql-server-ver17)

---

## Уникайте `SELECT *`

> *«Той, хто б'є у темряву, рідко влучає в ціль.»*

**Погано:**

```sql
SELECT * FROM dbo.Orders
```

**Добре:**

```sql
SELECT OrderID, OrderDate, Amount FROM dbo.Orders
```

---

## Використовуйте #temp та @table там де це доречно

> *«Глечик і чашка несуть різний напій — обирай посуд за потребою.»*

* \#temp — для великих наборів (1000 і більше рядків), які потребують обробки.
* @table — для малих, швидких операцій.

**Приклад #temp:**

```sql
SELECT * INTO #tmpOrders FROM dbo.Orders WHERE Amount > 1000
```

**Приклад @table:**

```sql
DECLARE @SmallTable TABLE (ID int)
INSERT @SmallTable VALUES (1),(2),(3)
```

---

## CREATE TABLE замість SELECT INTO

> *«Той, хто креслить меча в тумані, може поранити себе.»*

Краще використовувати `CREATE TABLE` для створення таблиць з визначенням типів даних та індексів.
Тоді як `SELECT INTO` створює таблицю з типами даних, які SQL Server визначає автоматично, що може призвести до неочікуваних результатів.

**Погано:**

```sql
SELECT * INTO #tmpOrders FROM dbo.Orders WHERE Amount > 1000
```

**Добре:**

```sql
CREATE TABLE #tmpOrders (
  OrderID int,
  OrderDate datetime,
  Amount decimal(18,2)
)
INSERT INTO #tmpOrders (OrderID, OrderDate, Amount)
SELECT OrderID, OrderDate, Amount FROM dbo.Orders WHERE Amount > 1000
```

---

## Додавайте індекси навіть на тимчасові таблиці

> *Стежка освічена місячним світлом, краще ніж дорога у пітьмі.*

```sql
CREATE TABLE #tmpOrders (
  OrderID int,
  CustomerID int,
  Amount decimal(18,2)
)
CREATE INDEX IX_TempOrders_CustomerID ON #tmpOrders (CustomerID)
```

---

## Фільтруйте зайве одразу

> *«Шлях легший для того, хто не несе зайвого.»*

Спочатку фільтруємо, потім групуємо, потім — об'єднуємо.

```sql
WITH filtered_orders AS (
  SELECT * FROM dbo.Orders WHERE OrderDate >= '2025-01-01'
)
SELECT CustomerID, COUNT(*) FROM filtered_orders GROUP BY CustomerID
```

---

## Використовуйте EXISTS коли потрібно перевірити наявність

> *«Один точний удар краще тисячі сліпих помахів.»*

Замість IN або JOIN, коли потрібно перевірити наявність рядків у іншій таблиці, використовуйте EXISTS.

**Жахливо:**

```sql
SELECT * FROM dbo.Orders WHERE CustomerID IN (SELECT CustomerID FROM dbo.VIPCustomers)
```

**Не ідеально:**

```sql
SELECT * FROM dbo.Orders o JOIN dbo.VIPCustomers v ON o.CustomerID = v.CustomerID
```

**Те що потрібно:**

```sql
SELECT * FROM dbo.Orders o WHERE EXISTS (
  SELECT 1 FROM dbo.VIPCustomers v WHERE v.CustomerID = o.CustomerID
)
```

[EXISTS](https://learn.microsoft.com/uk-ua/sql/t-sql/language-elements/exists-transact-sql?view=sql-server-ver17)

---

## Використовуйте CTE або APPLY замість вкладених запитів

> *«Ясний розум бачить шлях навіть у заплутаному лісі.»*

[WITH common\_table\_expression - SQL Server | Microsoft Learn](https://learn.microsoft.com/uk-ua/sql/t-sql/queries/with-common-table-expression-transact-sql?view=sql-server-ver17)

**Погано:**

```sql
SELECT o.OrderID, c.CustomerName
FROM dbo.Orders o JOIN (
  SELECT CustomerID, CustomerName FROM dbo.Customers where CustomerType = 'VIP'
) c ON o.CustomerID = c.CustomerID
```

**Добре:**

```sql
WITH VIPCustomers AS (
  SELECT CustomerID, CustomerName FROM dbo.Customers WHERE CustomerType = 'VIP'
)
SELECT o.OrderID, c.CustomerName
FROM dbo.Orders o JOIN VIPCustomers c ON o.CustomerID = c.CustomerID
```

```sql
SELECT o.OrderID, c.CustomerName
FROM dbo.Orders o CROSS APPLY (
  SELECT CustomerID, CustomerName
  FROM dbo.Customers
  WHERE CustomerType = 'VIP'
    AND CustomerID = o.CustomerID
) c
```

---

## Слідкуйте за типами даних

> *«Як вода і олія - число і рядок.»*

Стежте за типами даних у порівняннях.
Конвертація суттєво сповільнить запит.

**Погано:**

```sql
WHERE varcharField = 1234
```

**Добре:**

```sql
WHERE varcharField = '1234'
```

---

## Уникайте недетермінованих функцій у WHERE

> *«Сліпий - не може знайти вірний шлях.»*

[Deterministic and nondeterministic functions - SQL Server | Microsoft Learn](https://learn.microsoft.com/uk-ua/sql/relational-databases/user-defined-functions/deterministic-and-nondeterministic-functions?view=sql-server-ver17)

**Погано:**

```sql
WHERE ORDERDATE >= DATEADD(DAY, -1, GETDATE())
```

**Добре:**

```sql
DECLARE @yesterday DATE =  DATEADD(DAY, -1, GETDATE())
WHERE OrderDate >= @yesterday
```

---
 
## CONCAT замість додавання рядків ('+') 
> *«Слова, що зливаються, створюють гармонію.»*

**Погано:**
```sql
SELECT 'No' + orderId, OrderDate, Amount FROM dbo.Orders
```

**Добре:**
```sql
SELECT CONCAT('No', OrderID), OrderDate, Amount
FROM dbo.Orders
```  