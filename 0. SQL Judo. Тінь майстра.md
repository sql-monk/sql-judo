---
layout: default
title: "Тінь майстра"

---

# SQL Judo. Тінь майстра
> *Тінь майстра — це не наука і не правило, це відчуття, що робити абияк тут не можна.
Навіть коли ти один, вона спонукає працювати краще.*
![shadow](shadow.png)
 

---
 

## Вивчайте структуру даних

> *«Той, хто бачить зерно, не загубить поле.»*

Починайте із вивчення структури таблиць, типів полів та індексів.

```sql
sp_help 'dbo.YourTable'
```

[sp_help](https://learn.microsoft.com/en-us/sql/relational-databases/system-stored-procedures/sp-help-transact-sql?view=sql-server-ver17)

```sql
SELECT * 
FROM sys.dm_exec_describe_first_result_set(
  N'SELECT 
    CustomerID, 
    TerritoryID, 
    AccountNumber 
  FROM Sales.Customer 
  WHERE CustomerID = @CustomerID;',  
  N'@CustomerID int', 
  0
) a;  
```
```sql
SELECT *
FROM sys.dm_exec_describe_first_result_set (N'SELECT * FROM dbo.YourTable', NULL, 0);
```
[dm_exec_describe_first_result_set](https://learn.microsoft.com/sql/relational-databases/system-dynamic-management-views/sys-dm-exec-describe-first-result-set-transact-sql?view=sql-server-ver17)

[sp_describe_first_result_set](https://learn.microsoft.com/sql/relational-databases/system-stored-procedures/sp-describe-first-result-set-transact-sql?view=sql-server-ver17)

---

## Уникайте `SELECT *`

> *«Той, хто б'є у темряву, рідко влучає в ціль.»*

**Погано:**

```sql
SELECT * FROM dbo.Orders
```

**Добре:**

```sql
SELECT OrderID, OrderDate, Amount FROM dbo.Orders
```

---

## Використовуйте #temp та @table там де це доречно

> *«Глечик і чашка несуть різний напій — обирай посуд за потребою.»*

* \#temp — для великих наборів (1000 і більше рядків), які потребують обробки.
* @table — для малих, швидких операцій.

**Приклад #temp:**

```sql
SELECT * INTO #tmpOrders FROM dbo.Orders WHERE Amount > 1000
```

**Приклад @table:**

```sql
DECLARE @SmallTable TABLE (ID int)
INSERT @SmallTable VALUES (1),(2),(3)
```

---

## CREATE TABLE замість SELECT INTO

> *«Той, хто креслить меча в тумані, може поранити себе.»*

Краще використовувати `CREATE TABLE` для створення таблиць з визначенням типів даних та індексів.
Тоді як `SELECT INTO` створює таблицю з типами даних, які SQL Server визначає автоматично, що може призвести до неочікуваних результатів.

**Погано:**

```sql
SELECT * INTO #tmpOrders FROM dbo.Orders WHERE Amount > 1000
```

**Добре:**

```sql
CREATE TABLE #tmpOrders (
  OrderID int,
  OrderDate datetime,
  Amount decimal(18,2)
)
INSERT INTO #tmpOrders (OrderID, OrderDate, Amount)
SELECT OrderID, OrderDate, Amount FROM dbo.Orders WHERE Amount > 1000
```

---

## Додавайте індекси навіть на тимчасові таблиці

> *Стежка освічена місячним світлом, краще ніж дорога у пітьмі.*

```sql
CREATE TABLE #tmpOrders (
  OrderID int,
  CustomerID int,
  Amount decimal(18,2)
)
CREATE INDEX IX_TempOrders_CustomerID ON #tmpOrders (CustomerID)
```
 
---

## Використовуйте CTE або APPLY замість вкладених запитів

> *«Ясний розум бачить шлях навіть у заплутаному лісі.»*

[WITH common\_table\_expression](https://learn.microsoft.com/uk-ua/sql/t-sql/queries/with-common-table-expression-transact-sql?view=sql-server-ver17)

**Погано:**

```sql
SELECT o.OrderID, c.CustomerName
FROM dbo.Orders o JOIN (
  SELECT CustomerID, CustomerName FROM dbo.Customers where CustomerType = 'VIP'
) c ON o.CustomerID = c.CustomerID
```

**Добре:**

```sql
WITH VIPCustomers AS (
  SELECT CustomerID, CustomerName FROM dbo.Customers WHERE CustomerType = 'VIP'
)
SELECT o.OrderID, c.CustomerName
FROM dbo.Orders o JOIN VIPCustomers c ON o.CustomerID = c.CustomerID
```

```sql
SELECT o.OrderID, c.CustomerName
FROM dbo.Orders o CROSS APPLY (
  SELECT CustomerID, CustomerName
  FROM dbo.Customers
  WHERE CustomerType = 'VIP'
    AND CustomerID = o.CustomerID
) c
```
 

---
 
## CONCAT замість додавання рядків (`+`) 
> *«Слова, що зливаються, створюють гармонію.»*

**Погано:**
```sql
SELECT 'No' + orderId, OrderDate, Amount FROM dbo.Orders
```

**Добре:**
```sql
SELECT CONCAT('No', OrderID), OrderDate, Amount
FROM dbo.Orders
```  


---

## Function vs View — що і коли

> *«Меч і спис — різна зброя, але обидві виграють битву, якщо обрати їх вчасно.»*

### **VIEW**

* Використовується для представлення даних як збереженого запиту.
* Добре підходить для **простих або складних JOIN’ів** і агрегацій, коли потрібно мати готовий набір даних, який можна легко повторно використовувати у запитах.
* Не приймає параметрів.
* Оптимізатор часто вбудовує (`inline`) логіку VIEW у головний запит, що спрощує оптимізацію.
* **Може викликати функції** (скалярні або табличні), але пам’ятайте — скалярні функції у SELECT або WHERE можуть сильно сповільнити виконання, бо виконуються построчно.

**Приклад:**

```sql
CREATE VIEW Sales.vw_TopCustomers AS
SELECT TOP 100 
    CustomerID, 
    dbo.fn_CustomerCategory(CustomerID) AS Category,
    SUM(Amount) TotalAmount
FROM Sales.Orders
GROUP BY CustomerID
ORDER BY SUM(Amount) DESC
```

---

### **FUNCTION**

* Може бути **табличною** (`inline` або `multi-statement`) або **скалярною**.
* Дозволяє **передавати параметри**, що робить її гнучкою для вибірок з різними умовами.
* Inline table-valued function (iTVF) часто оптимізується так само, як VIEW.
* Multi-statement table-valued function (mTVF) і скалярні UDF можуть бути повільними — оптимізатор виконує їх построчно, без `parallelism`.
* Зручно виносити повторювану логіку, особливо з параметрами, для використання як у запитах, так і у VIEW.

**Приклад inline TVF:**

```sql
CREATE FUNCTION Sales.fn_TopCustomers(@TopN int)
RETURNS TABLE
AS
RETURN
  SELECT TOP (@TopN) CustomerID, SUM(Amount) TotalAmount
  FROM Sales.Orders
  GROUP BY CustomerID
  ORDER BY SUM(Amount) DESC
```

---

### **Коли обрати VIEW**

* Потрібен **фіксований набір даних** без параметрів.
* Часто використовується в **звітах** і як шар абстракції над складними SQL.
* Хочете, щоб оптимізатор максимально інтегрував логіку в запит.
* Коли потрібно **викликати функцію для обчислень** у кожному рядку, але пам’ятайте про можливі втрати продуктивності.

### **Коли обрати FUNCTION**

* Потрібна **параметризація** логіки.
* Хочете **повторно використовувати складний фільтр або обчислення** у різних місцях.
* Inline TVF — коли важлива продуктивність.
* Multi-statement TVF — тільки якщо немає простішої альтернативи.
* Плануєте використати функцію **як частину VIEW** для збагачення даних.

---
