# #temp (локальна тимчасова таблиця в tempdb)

Плюси

Область видимості — поточна сесія/процедура; немає конфліктів імен.

Швидке створення/дроп; автостатистика, можна індекси.

Не потрапляє в бекапи користувацьких БД (менше тягаря на бекап).

Ідеально для buffer-робіт і коротких stage-кроків «у середині» запиту/процедури.

Мінуси

Конкуренція за ресурси tempdb (особливо при масовому ETL).

Життєвий цикл = сесія: не підходить для міжкрокових пайплайнів/аудиту.

Обмежене керування розподілом даних (все в tempdb).

Коли брати

Трансформації «тут і зараз», сортування/віконні агрегації, проміжні джойни у складних запитах.

Коли важливі швидкість і простота, а не збереження результатів.

# ##temp (глобальна тимчасова таблиця в tempdb)

Плюси

Доступна між сесіями — можна ділитися буфером між джобами/процесами.

Ті самі переваги, що й у #temp (індекси/статистика).

Мінуси

Ризик зіткнень імен та гонок (потрібні унікальні найменування/протокол).

Все ще навантажує tempdb; керування життєвим циклом складніше.

Без історії/версійності (все одно тимчасове).

Коли брати

Коротка спільна «передача естафети» між процесами, коли повноцінний stage «зайвий».

# Таблиці в існуючій БД

## У Primary файловій групі

Плюси

Мінімальна орг-складність: таблиці «поруч» із моделлю.

Спадкує безпеку/права/бекап-політики БД.

Мінуси

Змішування OLTP/аналітики із stage навантаженням → фрагментація, конкуренція за I/O і журнал.

Бекап/відновлення важчають (stage дані тягнуться у бекапи).

Трудно контролювати розмір і SHRINK шкодить продуктивності.

Коли брати

Невеликі обсяги, рідкі завантаження, прості сценарії.

## В окремій файловій групі тієї ж БД

Плюси

Поділ I/O та керованість: можна винести файли на інші диски.

Простішe керування ростом/очисткою (автогроус, таргетований індекс-обслуговування).

Можливість partial backups/restore (за політикою).

Мінуси

Все ще в межах тієї ж БД → вплив на журнал/бекап цієї БД.

Потрібна початкова підготовка (фг, файли, політики).

Коли брати

Постійний stage зі значними обсягами, але хочете зберегти єдину БД і спільні схеми/права.

# Окрема БД для stage

Плюси

Повна ізоляція I/O, окремий журнал, власні бекап-політики (часто — SIMPLE).

Легше робити truncate/drop масово, не чіпаючи прод-об’єкти.

Можна налаштувати окремі файлові групи, диски, квоти, моніторинг.

Мінуси

Адмін-комплексність: ще одна БД, доступи, джоб-пайплайни, моніторинг.

Потрібно продумати схеми безпеки між БД (пермішени/синоніми/externals).

Коли брати

Справжній DWH-stage: великі потоки, SLA на прийом/очищення, аудит/логи, можливість окремих вікон обслуговування.

Ризики та нюанси (коротко)

tempdb: слідкуйте за розміром, автогроус, кількістю файлів, «гарячими» PFS/SGAM/GAM. Масові SELECT INTO і важкі сортування можуть «забити» tempdb.

Бекапи/відновлення: stage у прод-БД → довші бекапи/restore. Окрема БД або окрема ФГ знімають біль.

Блокування: SELECT INTO/масові вставки в «ті самі» таблиці stage у спільній ФГ з «постійними» даними = конкуренція за I/O/журнал. Краще в окрему ФГ або окрему БД.

Очистка: часті створення/видалення великих stage-таблиць у Primary → фрагментація. Виділяйте окрему ФГ або окрему БД.

Безпека: у загальних ##temp — ризики витоку/перекриття; у окремій БД — тонке налаштування ролей/логінів.

---

## матриця вибору

| Сценарій                                        | Рекомендація                     |
| ----------------------------------------------- | -------------------------------- |
| Разовий буфер у межах запиту або процедури      | `#temp`                          |
| Короткочасне спільне використання між процесами | `##temp`                         |
| Stage невеликого обсягу                         | Таблиця в окремій ФГ існуючої БД |
| Великий постійний Stage                         | Окрема БД з SIMPLE recovery      |

---
 
