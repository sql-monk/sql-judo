---
layout: default
title: "Мистецтво тимчасового"
---

# SQL Judo. Мистецтво тимчасового

> *«Глечик і чашка несуть різний напій — обирай посуд за потребою.»*
![art](art.png)
У битві за швидкість запиту важливо правильно обрати посудину для тимчасових даних. У нашому арсеналі є три основні типи тимчасових об'єктів: **табличні змінні** (`@table`), **локальні тимчасові таблиці** (`#table`) та **глобальні тимчасові таблиці** (`##table`). 

Кожен інструмент має свій стиль боротьби, унікальні переваги та специфічні обмеження. Майстерність полягає в умінні обрати правильний інструмент для конкретного завдання.

---

## @table — Таблична змінна

> *«Легкість пір'їни, швидкість думки.»*

### Характеристики:
- **Місце зберігання:** Оперативна пам'ять (RAM), не використовує tempdb
- **Продуктивність:** Надзвичайно швидка для невеликих обсягів (до ~1000 рядків)
- **Область видимості:** Лише в межах поточного batch або процедури
- **Унікальність:** Єдиний дозволений тип тимчасової таблиці всередині функцій
- **Життєвий цикл:** Зникає одразу після завершення batch або функції

### Переваги:
✅ Мінімальне навантаження на tempdb  
✅ Швидкий доступ до даних  
✅ Автоматичне очищення пам'яті  
✅ Підтримка в скалярних та табличних функціях  

### Обмеження:
❌ Відсутність повноцінних індексів (лише PRIMARY KEY та UNIQUE)  
❌ Немає статистики для оптимізатора  
❌ Погана продуктивність при великих обсягах даних  
❌ Неможливість використання в динамічному SQL  
❌ Існує доки виконується запит  

### Приклади використання:

**Базовий приклад:**
```sql
DECLARE @OrderIDs TABLE (
    OrderID INT PRIMARY KEY,
    CustomerID INT NOT NULL,
    OrderDate DATE DEFAULT GETDATE()
);

INSERT INTO @OrderIDs (OrderID, CustomerID) 
VALUES (1, 101), (2, 102), (3, 103);

SELECT * FROM @OrderIDs;
```

**У функції для повернення результату:**
```sql
CREATE FUNCTION dbo.GetActiveCustomers()
RETURNS @ActiveCustomers TABLE (
    CustomerID INT,
    CustomerName NVARCHAR(100),
    LastOrderDate DATE
)
AS
BEGIN
    INSERT INTO @ActiveCustomers
    SELECT 
        c.CustomerID,
        c.CustomerName,
        MAX(o.OrderDate)
    FROM Customers c
    INNER JOIN Orders o ON c.CustomerID = o.CustomerID
    WHERE o.OrderDate >= DATEADD(MONTH, -6, GETDATE())
    GROUP BY c.CustomerID, c.CustomerName;
    
    RETURN;
END;
```

**Для швидкої фільтрації в складних запитах:**
```sql
DECLARE @ImportantCustomers TABLE (CustomerID INT PRIMARY KEY);

INSERT INTO @ImportantCustomers 
SELECT CustomerID 
FROM Customers 
WHERE TotalSpend > 10000;

-- Використання для швидкого JOIN
SELECT o.OrderID, o.OrderDate, c.CustomerName
FROM Orders o
INNER JOIN @ImportantCustomers ic ON o.CustomerID = ic.CustomerID
INNER JOIN Customers c ON ic.CustomerID = c.CustomerID
WHERE o.OrderDate >= '2024-01-01';
```

---

## #table — Локальна тимчасова таблиця

> *«Залишається, доки б'ється серце того, хто її створив.»*

### Характеристики:
- **Місце зберігання:** tempdb база даних
- **Продуктивність:** Оптимальна для середніх та великих обсягів даних
- **Область видимості:** Доступна лише в межах однієї сесії (connection)
- **Гнучкість:** Повна підтримка індексів, статистики та обмежень
- **Життєвий цикл:** Існує до кінця сесії або явного видалення

### Переваги:
✅ Повна підтримка індексів (кластерних та некластерних)  
✅ Автоматична генерація статистики для оптимізатора  
✅ Підтримка всіх типів обмежень (CHECK, FOREIGN KEY)  
✅ Можливість використання в динамічному SQL  
✅ Ефективна робота з великими наборами даних  
✅ Підтримка паралельних планів виконання  

### Обмеження:
❌ Використовує ресурси tempdb  
❌ Потенційні блокування в tempdb  
❌ Неможливість використання всередині функцій  
❌ Накладні витрати на створення метаданих  

### Приклади використання:

**Створення з індексами та обмеженнями:**
```sql
CREATE TABLE #OrderAnalysis (
    OrderID INT NOT NULL,
    CustomerID INT NOT NULL,
    OrderDate DATE NOT NULL,
    TotalAmount DECIMAL(18,2) NOT NULL,
    Status VARCHAR(20) NOT NULL DEFAULT 'Pending',
    ProcessedDate DATETIME2 NOT NULL DEFAULT SYSDATETIME(),
    
    CONSTRAINT PK_OrderAnalysis PRIMARY KEY CLUSTERED (OrderID),
    CONSTRAINT CK_OrderAnalysis_Amount CHECK (TotalAmount >= 0),
    INDEX IX_OrderAnalysis_Customer NONCLUSTERED (CustomerID),
    INDEX IX_OrderAnalysis_Date NONCLUSTERED (OrderDate) INCLUDE (TotalAmount)
);

-- Заповнення даними
INSERT INTO #OrderAnalysis (OrderID, CustomerID, OrderDate, TotalAmount)
SELECT OrderID, CustomerID, OrderDate, TotalAmount
FROM Orders 
WHERE OrderDate >= DATEADD(MONTH, -3, GETDATE());

-- Додавання індексу після заповнення (іноді ефективніше)
CREATE NONCLUSTERED INDEX IX_OrderAnalysis_Status 
ON #OrderAnalysis (Status) 
WHERE Status IN ('Pending', 'Processing');
```

**Для обробки великих обсягів даних:**
```sql
-- Створення таблиці для обробки мільйонів записів
CREATE TABLE #BigDataProcessing (
    ID BIGINT IDENTITY(1,1) PRIMARY KEY,
    SourceID INT NOT NULL,
    ProcessedData NVARCHAR(MAX),
    HashValue VARBINARY(32),
    CreatedDate DATETIME2 DEFAULT SYSDATETIME(),
    
    INDEX IX_BigData_Source NONCLUSTERED (SourceID)
);

-- Обробка даними партіями
DECLARE @BatchSize INT = 10000;
DECLARE @ProcessedCount INT = 0;

WHILE EXISTS (SELECT 1 FROM SourceTable WHERE IsProcessed = 0)
BEGIN
    INSERT INTO #BigDataProcessing (SourceID, ProcessedData, HashValue)
    SELECT TOP (@BatchSize)
        ID,
        dbo.ProcessComplexData(RawData),
        HASHBYTES('SHA2_256', RawData)
    FROM SourceTable 
    WHERE IsProcessed = 0;
    
    SET @ProcessedCount += @@ROWCOUNT;
    
    -- Оновлення статистики для кращої оптимізації
    IF @ProcessedCount % 50000 = 0
        UPDATE STATISTICS #BigDataProcessing;
        
    PRINT CONCAT('Processed: ', @ProcessedCount, ' records');
END;
```

**Для складної аналітики з CTE:**
```sql
CREATE TABLE #CustomerMetrics (
    CustomerID INT PRIMARY KEY,
    TotalOrders INT,
    TotalAmount DECIMAL(18,2),
    AvgOrderValue DECIMAL(18,2),
    FirstOrderDate DATE,
    LastOrderDate DATE,
    CustomerLifetimeMonths INT,
    CustomerSegment VARCHAR(20),
    
    INDEX IX_CustomerMetrics_Segment NONCLUSTERED (CustomerSegment)
);

-- Заповнення за допомогою складної аналітики
WITH CustomerAnalytics AS (
    SELECT 
        CustomerID,
        COUNT(*) as TotalOrders,
        SUM(TotalAmount) as TotalAmount,
        AVG(TotalAmount) as AvgOrderValue,
        MIN(OrderDate) as FirstOrderDate,
        MAX(OrderDate) as LastOrderDate,
        DATEDIFF(MONTH, MIN(OrderDate), MAX(OrderDate)) + 1 as CustomerLifetimeMonths
    FROM Orders
    GROUP BY CustomerID
),
CustomerSegmentation AS (
    SELECT *,
        CASE 
            WHEN TotalAmount >= 50000 THEN 'VIP'
            WHEN TotalAmount >= 10000 THEN 'Premium'
            WHEN TotalAmount >= 1000 THEN 'Standard'
            ELSE 'Basic'
        END as CustomerSegment
    FROM CustomerAnalytics
)
INSERT INTO #CustomerMetrics
SELECT * FROM CustomerSegmentation;

-- Аналіз результатів
SELECT 
    CustomerSegment,
    COUNT(*) as CustomerCount,
    AVG(TotalAmount) as AvgLifetimeValue,
    AVG(AvgOrderValue) as AvgOrderValue
FROM #CustomerMetrics
GROUP BY CustomerSegment
ORDER BY AvgLifetimeValue DESC;
```

---

### Особливості `#table` у процедурах: приклади та нюанси

> *«Працюй із посудиною там, де вона стала — і не ламай ритм поєдинку.»*

#### Видимість і життєвий цикл у процедурах

Локальна тимчасова таблиця, створена в процедурі, автоматично видаляється після завершення **цієї** процедури. Вона доступна **вкладеним** процедурам, але **не** доступна зовнішньому виклику, який її запустив. Це прямо зазначено в документації (SQL Server 2022) про `CREATE TABLE` та тимчасові таблиці. ([Microsoft Learn](https://learn.microsoft.com/en-us/sql/t-sql/statements/create-table-transact-sql?view=sql-server-ver17&utm_source=chatgpt.com))

**Приклад A → B (бачить), поза A (не бачить):**

```sql
CREATE OR ALTER PROCEDURE dbo.ProcB AS
BEGIN
    -- B бачить #t, бо її створив A вище по стеку
    INSERT INTO #t(v) VALUES (N'from B');
END
GO

CREATE OR ALTER PROCEDURE dbo.ProcA AS
BEGIN
    CREATE TABLE #t (v nvarchar(100));
    INSERT INTO #t(v) VALUES (N'from A');

    EXEC dbo.ProcB;

    SELECT src = N'A call', * FROM #t;  -- працює
END
GO

-- ЗОВНІШНІЙ ВИКЛИК
EXEC dbo.ProcA;

-- ПОЗА ПРОЦЕДУРОЮ A #t НЕ ІСНУЄ -> помилка "Invalid object name '#t'"
-- SELECT * FROM #t;
```

Пояснення: `#t` існує лише в контексті `ProcA` та її вкладених викликів (тут — `ProcB`). Поза `ProcA` таблиці вже немає. [Microsoft Learn](https://learn.microsoft.com/en-us/sql/t-sql/statements/create-table-transact-sql?view=sql-server-ver17&utm_source=chatgpt.com)

---

####  Чому **не варто** поспішати з `DROP TABLE #t` у процедурах

SQL Server автоматично прибере локальні тимчасові таблиці після завершення процедури або сесії. У більшості випадків ручний `DROP` непотрібний і може нашкодити: викликати помилки у наступних кроках, спровокувати зайві компіляції планів і додаткове навантаження на `tempdb`-метадані. [Microsoft Learn](https://learn.microsoft.com/en-us/sql/t-sql/statements/create-table-transact-sql?view=sql-server-ver17&utm_source=chatgpt.com)

#### Потенційні наслідки передчасного `DROP`:

1. **Логічні помилки** у тій самій процедурі або у вкладених/наступних кроках (спроби звернутися до вже видаленої таблиці → `Invalid object name`).
2. **Зайві компіляції / кеш-планів «сміття»** при повторному створенні таблиці (DDL усередині процедури — це сигнал на компіляцію; чим більше створюємо/видаляємо, тим частіше «штовхаємо» оптимізатор). На практиці це відмічали як проблему продуктивності. [SQLServerCentral](https://www.sqlservercentral.com/forums/topic/temporary-tables-causing-stored-procedure-recompiles?utm_source=chatgpt.com), [sql.kiwi](https://www.sql.kiwi/2025/03/avoid-optional-spid/?utm_source=chatgpt.com)
3. **Навантаження на tempdb/метадані**: створення/видалення тимчасових об’єктів — це робота з каталогами tempdb. Часте `DROP` під тиском конкурентних сесій може підсилювати метадані-контеншн; SQL Server має механізм кешування тимчасових об’єктів, який якраз намагається зменшити цей вплив. [SQLPerformance.com](https://sqlperformance.com/2017/05/sql-performance/sql-server-temporary-object-caching?utm_source=chatgpt.com)

> Примітка про блокування: сам по собі `DROP TABLE #t` може блокувати інші сесії, якщо вони одночасно маніпулюють метаданими/структурами у tempdb (DDL завжди бере схематичні блокування на відповідних об’єктах). У реальних системах зустрічали кейси, де масові `DROP` у гарячих процедурах створювали помітні блокування на метаданих. Це не «лок по даних бізнес-таблиць», але реальний вузол у tempdb/каталогах. [SQLServerCentral](https://www.sqlservercentral.com/forums/topic/temp-table-tname-causing-database-blocking-on-drop-table-tname-call-win-stored-procedure?utm_source=chatgpt.com)
> Загальні принципи блокувань і версіонування описані в офіційній довідці. [Microsoft Learn](https://learn.microsoft.com/en-us/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide?view=sql-server-ver16&utm_source=chatgpt.com)

**Рекомендація:** якщо `#t` потрібна впродовж усієї процедури — **не дропай її вручну**; довір автоочищенню після завершення процедури. Якщо потрібно очистити дані — краще `TRUNCATE`/`DELETE` (за потреби), ніж `DROP/CREATE` по колу, щоб уникати зайвих компіляцій і тиску на метадані. Реюз тимчасових об’єктів підтримується самим SQL Server через кеш тимчасових об’єктів. [SQLPerformance.com](https://sqlperformance.com/2017/05/sql-performance/sql-server-temporary-object-caching?utm_source=chatgpt.com)

**Погано (DROP посеред процесу):**

```sql
CREATE OR ALTER PROCEDURE dbo.DoWork AS
BEGIN
    CREATE TABLE #stage (id int primary key, payload varbinary(100));

    -- ... крок 1
    -- передчасне видалення:
    DROP TABLE #stage;

    -- ... крок 2 ще потребує #stage -> тут ловимо "Invalid object name '#stage'"
    -- INSERT INTO #stage ...  -- помилка
END
GO
```

**Краще (без зайвих DDL і з можливістю «перезавантажити» дані):**

```sql
CREATE OR ALTER PROCEDURE dbo.DoWork AS
BEGIN
    CREATE TABLE #stage (id int primary key, payload varbinary(100));

    -- крок 1
    INSERT #stage(id, payload)
    SELECT TOP (10000) id, payload FROM dbo.Source WHERE IsReady = 1;

    -- якщо треба «очистити» і перевикористати таблицю:
    TRUNCATE TABLE #stage; -- мінімальні метадані-операції

    -- крок 2
    INSERT #stage(id, payload)
    SELECT TOP (10000) id, payload FROM dbo.Source WHERE IsReady = 0;

    -- НІЯКОГО DROP тут не потрібно — SQL Server прибере #stage по завершенні процедури
END
GO
```

---

####  «Де створювати `#table`: у викликаючому контексті чи всередині?»

* Якщо `#table` потрібна **для всієї низки вкладених викликів** — створюй її «вище» (у «wrapper»-процедурі або в calling-сценарії), щоб усі підпроцедури бачили її, і **не дропай** до завершення всього ланцюжка:

```sql
CREATE OR ALTER PROCEDURE dbo.Wrapper AS
BEGIN
    CREATE TABLE #work (k int primary key, v int);

    EXEC dbo.Step1;  -- бачить #work
    EXEC dbo.Step2;  -- теж бачить #work

    -- можна прибрати дані, якщо потрібно повторити:
    -- TRUNCATE TABLE #work;

    -- По виходу з Wrapper #work буде знищена автоматично
END
GO
```

* Якщо `#table` — **внутрішній технічний буфер** лише для однієї процедури, створюй її **там** і **не видаляй вручну**: хай зникне автоматично після завершення. Це узгоджується з поведінкою, описаною в офіційній документації. [Microsoft Learn](https://learn.microsoft.com/en-us/sql/t-sql/statements/create-table-transact-sql?view=sql-server-ver17&utm_source=chatgpt.com)

---

####  Приклад із планами: уникай «DROP/CREATE» по колу

Часті DDL над тимчасовими таблицями в середині процедури можуть провокувати зайві компіляції/кеш-варіанти планів і навантаження на tempdb-метадані. Краще реюзити таблицю (TRUNCATE/DELETE) — це дружніше до план-кешу і tempdb. Практика та розслідування спільноти це підтверджують.
[SQLServerCentral](https://www.sqlservercentral.com/forums/topic/temporary-tables-causing-stored-procedure-recompiles?utm_source=chatgpt.com)    
[SQLPerformance.com](https://sqlperformance.com/2017/05/sql-performance/sql-server-temporary-object-caching?utm_source=chatgpt.com)    
[sql.kiwi](https://www.sql.kiwi/2025/03/avoid-optional-spid/?utm_source=chatgpt.com)    

**Погано (DROP/CREATE багаторазово):**

```sql
CREATE OR ALTER PROCEDURE dbo.ManyParts AS
BEGIN
    DECLARE @i int = 1;
    WHILE @i <= 5
    BEGIN
        CREATE TABLE #buf (id int, c1 int);
        INSERT #buf SELECT id, c1 FROM dbo.Big WHERE Part = @i;

        -- робота...

        DROP TABLE #buf;  -- кожен цикл: DDL + потенційні перекомпіляції
        SET @i += 1;
    END
END
GO
```

**Краще (одна створена таблиця + TRUNCATE):**

```sql
CREATE OR ALTER PROCEDURE dbo.ManyParts AS
BEGIN
    CREATE TABLE #buf (id int, c1 int);

    DECLARE @i int = 1;
    WHILE @i <= 5
    BEGIN
        TRUNCATE TABLE #buf;  -- без DDL, мінімум метаданих
        INSERT #buf SELECT id, c1 FROM dbo.Big WHERE Part = @i;

        -- робота...

        SET @i += 1;
    END
END
GO
```

---
 

### Висновок

* **Не дропай `#table` у процедурах без нагальної потреби** — покладайся на автоочищення. Це зменшує ризики логічних помилок, зайвих перекомпіляцій і метадані-контеншну в `tempdb`. [Microsoft Learn](https://learn.microsoft.com/en-us/sql/t-sql/statements/create-table-transact-sql?view=sql-server-ver17&utm_source=chatgpt.com), [SQLPerformance.com](https://sqlperformance.com/2017/05/sql-performance/sql-server-temporary-object-caching?utm_source=chatgpt.com)
* **Створюй там, де потрібно**, і/або у «верхньому» шарі, якщо таблиця має служити мостом між кількома кроками у межах однієї сесії. [Microsoft Learn](https://learn.microsoft.com/en-us/sql/t-sql/statements/create-table-transact-sql?view=sql-server-ver17&utm_source=chatgpt.com)
* **Якщо треба «перевикористовувати»** — надавай перевагу `TRUNCATE/DELETE` замість «DROP/CREATE по колу». [SQLPerformance.com](https://sqlperformance.com/2017/05/sql-performance/sql-server-temporary-object-caching?utm_source=chatgpt.com)
 
---

##  ##table — Глобальна тимчасова таблиця

> *«Міст між світами — з'єднує, але потребує обережності.»*

### Характеристики:
- **Місце зберігання:** tempdb база даних
- **Область видимості:** Доступна для всіх сесій на сервері
- **Життєвий цикл:** Існує доки жива хоча б одна сесія, що її використовує
- **Унікальність імені:** Ім'я має бути унікальним на рівні всього сервера
- **Безпека:** Потенційний ризик конфліктів імен та несанкціонованого доступу

### Переваги:
✅ Можливість обміну даними між сесіями  
✅ Повна підтримка індексів та статистики  
✅ Ефективна для координації між процесами  
✅ Підтримка складних операцій JOIN між сесіями  

### Обмеження та ризики:
❌ Конфлікти імен між різними додатками  
❌ Проблеми безпеки - доступ з інших сесій  
❌ Складність контролю життєвого циклу  
❌ Потенційні витоки пам'яті при неправильному використанні  
❌ Неможливість використання в функціях  

### Коли використовувати:
- Координація між паралельними процесами
- Кешування даних для багатьох сесій
- Передача великих наборів даних між процедурами в різних сесіях
- Реалізація простих механізмів блокування

### Приклади використання:

**Координація між паралельними процесами:**
```sql
-- Процес координатор створює таблицю для відстеження статусу
CREATE TABLE ##ProcessStatus (
    ProcessID INT PRIMARY KEY,
    ProcessName VARCHAR(100) NOT NULL,
    Status VARCHAR(20) NOT NULL DEFAULT 'Starting',
    StartTime DATETIME2 NOT NULL DEFAULT SYSDATETIME(),
    EndTime DATETIME2 NULL,
    ErrorMessage NVARCHAR(MAX) NULL,
    
    INDEX IX_ProcessStatus_Status NONCLUSTERED (Status)
);

-- Ініціалізація процесів
INSERT INTO ##ProcessStatus (ProcessID, ProcessName)
VALUES 
    (1, 'DataImport'),
    (2, 'DataValidation'), 
    (3, 'DataTransformation'),
    (4, 'ReportGeneration');

-- В кожному паралельному процесі:
-- Процес 1 (імпорт даних)
UPDATE ##ProcessStatus 
SET Status = 'Running', StartTime = SYSDATETIME() 
WHERE ProcessID = 1;

-- ... виконання роботи ...

UPDATE ##ProcessStatus 
SET Status = 'Completed', EndTime = SYSDATETIME() 
WHERE ProcessID = 1;
```

**Кешування довідкових даних:**
```sql
-- Перевірка існування кешу
IF OBJECT_ID('tempdb..##ReferenceDataCache') IS NULL
BEGIN
    CREATE TABLE ##ReferenceDataCache (
        CacheKey VARCHAR(100) NOT NULL,
        CacheValue NVARCHAR(MAX) NOT NULL,
        ExpiryTime DATETIME2 NOT NULL,
        CreatedTime DATETIME2 NOT NULL DEFAULT SYSDATETIME(),
        
        PRIMARY KEY (CacheKey),
        INDEX IX_Cache_Expiry NONCLUSTERED (ExpiryTime)
    );
    
    -- Заповнення кешу
    INSERT INTO ##ReferenceDataCache (CacheKey, CacheValue, ExpiryTime)
    SELECT 
        'Country_' + CountryCode,
        CountryName,
        DATEADD(HOUR, 24, SYSDATETIME()) -- Кеш на 24 години
    FROM Countries WHERE IsActive = 1;
    
    INSERT INTO ##ReferenceDataCache (CacheKey, CacheValue, ExpiryTime)
    SELECT 
        'Currency_' + CurrencyCode,
        CurrencyName + ' (' + CurrencySymbol + ')',
        DATEADD(HOUR, 24, SYSDATETIME())
    FROM Currencies WHERE IsActive = 1;
END;

-- Використання кешу
DECLARE @CountryName NVARCHAR(MAX);
SELECT @CountryName = CacheValue 
FROM ##ReferenceDataCache 
WHERE CacheKey = 'Country_US' 
    AND ExpiryTime > SYSDATETIME();

-- Очищення застарілого кешу
DELETE FROM ##ReferenceDataCache 
WHERE ExpiryTime <= SYSDATETIME();
```

**Безпечний патерн створення з унікальними іменами:**
```sql
-- Створення унікального імені з timestamp та SPID
DECLARE @TableName SYSNAME = '##SharedData_' + 
    CAST(@@SPID AS VARCHAR(10)) + '_' + 
    FORMAT(SYSDATETIME(), 'yyyyMMddHHmmss');

DECLARE @SQL NVARCHAR(MAX) = 
    'CREATE TABLE ' + @TableName + ' (
        ID INT IDENTITY(1,1) PRIMARY KEY,
        SessionID INT NOT NULL DEFAULT @@SPID,
        Data NVARCHAR(MAX) NOT NULL,
        CreatedTime DATETIME2 NOT NULL DEFAULT SYSDATETIME()
    )';

EXEC sp_executesql @SQL;

-- Повідомлення іншим процесам про ім'я таблиці
-- (через файл, реєстр, базу даних тощо)
```

### Не втрачайте пильність

1. **Завжди перевіряйте існування** перед створенням:
```sql
IF OBJECT_ID('tempdb..##MyTable') IS NOT NULL
    DROP TABLE ##MyTable;
```

2. **Використовуйте унікальні імена** для уникнення конфліктів:
```sql
DECLARE @UniqueTableName SYSNAME = '##MyApp_' + CAST(@@SPID AS VARCHAR(10)) + '_' + CAST(NEWID() AS VARCHAR(36));
```

3. **Завжди очищайте** за собою:
```sql
-- В кінці процедури або в блоці TRY/CATCH
IF OBJECT_ID('tempdb..##MyTable') IS NOT NULL
    DROP TABLE ##MyTable;
```

---

## Порівняння

| Критерій | @table (Таблична змінна) | #table (Локальна) | ##table (Глобальна) |
|----------|-------------------------|-------------------|---------------------|
| **Обсяг даних** | Малі (до 1000 рядків) | Середні й великі (1000+) | Всі обсяги |
| **Швидкість** | ⚡⚡⚡ Найшвидша | ⚡⚡ Швидка | ⚡ Повільніша |
| **Область видимості** | Лише поточний batch | Лише поточна сесія | Всі сесії сервера |
| **Використання у функціях** | ✅ Єдиний дозволений | ❌ Заборонено | ❌ Заборонено |
| **Підтримка індексів** | ⚠️ Обмежено (PK, UNIQUE) | ✅ Повна підтримка | ✅ Повна підтримка |
| **Статистика** | ❌ Відсутня | ✅ Автоматична | ✅ Автоматична |
| **Навантаження на tempdb** | ✅ Мінімальне | ⚠️ Помірне | ⚠️ Помірне |
| **Паралельні плани** | ❌ Не підтримуються | ✅ Підтримуються | ✅ Підтримуються |
| **Ризик конфліктів** | ✅ Відсутній | ✅ Відсутній | ❌ Високий |
| **Складність управління** | ✅ Проста | ✅ Проста | ❌ Складна |

## Практичні рекомендації вибору

### Використовуйте @table коли:
- **Кількість рядків < 1000**
- **Прості операції SELECT, INSERT**
- **Всередині функцій** (обов'язково)
- **Швидка фільтрація** у складних запитах
- **Тимчасове зберігання параметрів**
- **При роботі з JSON та XML**

### Використовуйте #table коли:
- **Кількість рядків > 1000**
- **Потрібні індекси** для оптимізації
- **Складні JOIN операції** за участю цієї таблиці
- **Багаторазове звернення** до даних в межах однієї сесії
- **Потрібна статистика** для планів виконання

### Використовуйте ##table коли:
- **Необхідний обмін даними** між сесіями (показати тимчасові дані іншим користувачам)
- **Координація паралельних процесів**
- **Кешування даних** для багатьох підключень
- **Простий механізм блокування**

---

## Ресурси та посилання

**Офіційна документація Microsoft:**
- [CREATE TABLE (Transact-SQL)](https://docs.microsoft.com/en-us/sql/t-sql/statements/create-table-transact-sql)
- [Table Variable vs Temp Table](https://docs.microsoft.com/en-us/sql/t-sql/data-types/table-transact-sql)
- [tempdb Database](https://docs.microsoft.com/en-us/sql/relational-databases/databases/tempdb-database)

**Блоги:**
- [Brent Ozar: "Table Variables vs. Temp Tables"](https://www.brentozar.com/archive/2020/03/table-variables-vs-temp-tables/)
- [Paul White: "Temporary Object Performance"](https://sqlperformance.com/2019/08/sql-performance/temporary-object-performance)
- [Kimberly Tripp: "Table Variables and Temp Tables"](https://www.sqlskills.com/blogs/kimberly/)

---

