---
layout: default
title: "Мистецтво тимчасового"
---

# SQL Judo. Мистецтво тимчасового

> *«Глечик і чашка несуть різний напій — обирай посуд за потребою.»*

У битві за швидкість запиту важливо правильно обрати посудину для тимчасових даних. У нашому арсеналі є три основні типи тимчасових об'єктів: **табличні змінні** (`@table`), **локальні тимчасові таблиці** (`#table`) та **глобальні тимчасові таблиці** (`##table`). 

Кожен інструмент має свій стиль боротьби, унікальні переваги та специфічні обмеження. Майстерність полягає в умінні обрати правильний інструмент для конкретного завдання.

---

## @table — Таблична змінна

> *«Легкість пір'їни, швидкість думки.»*

### Характеристики:
- **Місце зберігання:** Оперативна пам'ять (RAM), не використовує tempdb
- **Продуктивність:** Надзвичайно швидка для невеликих обсягів (до ~1000 рядків)
- **Область видимості:** Лише в межах поточного batch або процедури
- **Унікальність:** Єдиний дозволений тип тимчасової таблиці всередині функцій
- **Життєвий цикл:** Зникає одразу після завершення batch або функції

### Переваги:
✅ Мінімальне навантаження на tempdb  
✅ Швидкий доступ до даних  
✅ Автоматичне очищення пам'яті  
✅ Підтримка в скалярних та табличних функціях  

### Обмеження:
❌ Відсутність повноцінних індексів (лише PRIMARY KEY та UNIQUE)  
❌ Немає статистики для оптимізатора  
❌ Погана продуктивність при великих обсягах даних  
❌ Неможливість використання в динамічному SQL  
❌ Існує доки виконується запит  

### Приклади використання:

**Базовий приклад:**
```sql
DECLARE @OrderIDs TABLE (
    OrderID INT PRIMARY KEY,
    CustomerID INT NOT NULL,
    OrderDate DATE DEFAULT GETDATE()
);

INSERT INTO @OrderIDs (OrderID, CustomerID) 
VALUES (1, 101), (2, 102), (3, 103);

SELECT * FROM @OrderIDs;
```

**У функції для повернення результату:**
```sql
CREATE FUNCTION dbo.GetActiveCustomers()
RETURNS @ActiveCustomers TABLE (
    CustomerID INT,
    CustomerName NVARCHAR(100),
    LastOrderDate DATE
)
AS
BEGIN
    INSERT INTO @ActiveCustomers
    SELECT 
        c.CustomerID,
        c.CustomerName,
        MAX(o.OrderDate)
    FROM Customers c
    INNER JOIN Orders o ON c.CustomerID = o.CustomerID
    WHERE o.OrderDate >= DATEADD(MONTH, -6, GETDATE())
    GROUP BY c.CustomerID, c.CustomerName;
    
    RETURN;
END;
```

**Для швидкої фільтрації в складних запитах:**
```sql
DECLARE @ImportantCustomers TABLE (CustomerID INT PRIMARY KEY);

INSERT INTO @ImportantCustomers 
SELECT CustomerID 
FROM Customers 
WHERE TotalSpend > 10000;

-- Використання для швидкого JOIN
SELECT o.OrderID, o.OrderDate, c.CustomerName
FROM Orders o
INNER JOIN @ImportantCustomers ic ON o.CustomerID = ic.CustomerID
INNER JOIN Customers c ON ic.CustomerID = c.CustomerID
WHERE o.OrderDate >= '2024-01-01';
```

---

## #table — Локальна тимчасова таблиця

> *«Залишається, доки б'ється серце того, хто її створив.»*

### Характеристики:
- **Місце зберігання:** tempdb база даних
- **Продуктивність:** Оптимальна для середніх та великих обсягів даних
- **Область видимості:** Доступна лише в межах однієї сесії (connection)
- **Гнучкість:** Повна підтримка індексів, статистики та обмежень
- **Життєвий цикл:** Існує до кінця сесії або явного видалення

### Переваги:
✅ Повна підтримка індексів (кластерних та некластерних)  
✅ Автоматична генерація статистики для оптимізатора  
✅ Підтримка всіх типів обмежень (CHECK, FOREIGN KEY)  
✅ Можливість використання в динамічному SQL  
✅ Ефективна робота з великими наборами даних  
✅ Підтримка паралельних планів виконання  

### Обмеження:
❌ Використовує ресурси tempdb  
❌ Потенційні блокування в tempdb  
❌ Неможливість використання всередині функцій  
❌ Накладні витрати на створення метаданих  

### Приклади використання:

**Створення з індексами та обмеженнями:**
```sql
CREATE TABLE #OrderAnalysis (
    OrderID INT NOT NULL,
    CustomerID INT NOT NULL,
    OrderDate DATE NOT NULL,
    TotalAmount DECIMAL(18,2) NOT NULL,
    Status VARCHAR(20) NOT NULL DEFAULT 'Pending',
    ProcessedDate DATETIME2 NOT NULL DEFAULT SYSDATETIME(),
    
    CONSTRAINT PK_OrderAnalysis PRIMARY KEY CLUSTERED (OrderID),
    CONSTRAINT CK_OrderAnalysis_Amount CHECK (TotalAmount >= 0),
    INDEX IX_OrderAnalysis_Customer NONCLUSTERED (CustomerID),
    INDEX IX_OrderAnalysis_Date NONCLUSTERED (OrderDate) INCLUDE (TotalAmount)
);

-- Заповнення даними
INSERT INTO #OrderAnalysis (OrderID, CustomerID, OrderDate, TotalAmount)
SELECT OrderID, CustomerID, OrderDate, TotalAmount
FROM Orders 
WHERE OrderDate >= DATEADD(MONTH, -3, GETDATE());

-- Додавання індексу після заповнення (іноді ефективніше)
CREATE NONCLUSTERED INDEX IX_OrderAnalysis_Status 
ON #OrderAnalysis (Status) 
WHERE Status IN ('Pending', 'Processing');
```

**Для обробки великих обсягів даних:**
```sql
-- Створення таблиці для обробки мільйонів записів
CREATE TABLE #BigDataProcessing (
    ID BIGINT IDENTITY(1,1) PRIMARY KEY,
    SourceID INT NOT NULL,
    ProcessedData NVARCHAR(MAX),
    HashValue VARBINARY(32),
    CreatedDate DATETIME2 DEFAULT SYSDATETIME(),
    
    INDEX IX_BigData_Source NONCLUSTERED (SourceID)
);

-- Обробка даними партіями
DECLARE @BatchSize INT = 10000;
DECLARE @ProcessedCount INT = 0;

WHILE EXISTS (SELECT 1 FROM SourceTable WHERE IsProcessed = 0)
BEGIN
    INSERT INTO #BigDataProcessing (SourceID, ProcessedData, HashValue)
    SELECT TOP (@BatchSize)
        ID,
        dbo.ProcessComplexData(RawData),
        HASHBYTES('SHA2_256', RawData)
    FROM SourceTable 
    WHERE IsProcessed = 0;
    
    SET @ProcessedCount += @@ROWCOUNT;
    
    -- Оновлення статистики для кращої оптимізації
    IF @ProcessedCount % 50000 = 0
        UPDATE STATISTICS #BigDataProcessing;
        
    PRINT CONCAT('Processed: ', @ProcessedCount, ' records');
END;
```

**Для складної аналітики з CTE:**
```sql
CREATE TABLE #CustomerMetrics (
    CustomerID INT PRIMARY KEY,
    TotalOrders INT,
    TotalAmount DECIMAL(18,2),
    AvgOrderValue DECIMAL(18,2),
    FirstOrderDate DATE,
    LastOrderDate DATE,
    CustomerLifetimeMonths INT,
    CustomerSegment VARCHAR(20),
    
    INDEX IX_CustomerMetrics_Segment NONCLUSTERED (CustomerSegment)
);

-- Заповнення за допомогою складної аналітики
WITH CustomerAnalytics AS (
    SELECT 
        CustomerID,
        COUNT(*) as TotalOrders,
        SUM(TotalAmount) as TotalAmount,
        AVG(TotalAmount) as AvgOrderValue,
        MIN(OrderDate) as FirstOrderDate,
        MAX(OrderDate) as LastOrderDate,
        DATEDIFF(MONTH, MIN(OrderDate), MAX(OrderDate)) + 1 as CustomerLifetimeMonths
    FROM Orders
    GROUP BY CustomerID
),
CustomerSegmentation AS (
    SELECT *,
        CASE 
            WHEN TotalAmount >= 50000 THEN 'VIP'
            WHEN TotalAmount >= 10000 THEN 'Premium'
            WHEN TotalAmount >= 1000 THEN 'Standard'
            ELSE 'Basic'
        END as CustomerSegment
    FROM CustomerAnalytics
)
INSERT INTO #CustomerMetrics
SELECT * FROM CustomerSegmentation;

-- Аналіз результатів
SELECT 
    CustomerSegment,
    COUNT(*) as CustomerCount,
    AVG(TotalAmount) as AvgLifetimeValue,
    AVG(AvgOrderValue) as AvgOrderValue
FROM #CustomerMetrics
GROUP BY CustomerSegment
ORDER BY AvgLifetimeValue DESC;
```

---

##  ##table — Глобальна тимчасова таблиця

> *«Міст між світами — з'єднує, але потребує обережності.»*

### Характеристики:
- **Місце зберігання:** tempdb база даних
- **Область видимості:** Доступна для всіх сесій на сервері
- **Життєвий цикл:** Існує доки жива хоча б одна сесія, що її використовує
- **Унікальність імені:** Ім'я має бути унікальним на рівні всього сервера
- **Безпека:** Потенційний ризик конфліктів імен та несанкціонованого доступу

### Переваги:
✅ Можливість обміну даними між сесіями  
✅ Повна підтримка індексів та статистики  
✅ Ефективна для координації між процесами  
✅ Підтримка складних операцій JOIN між сесіями  

### Обмеження та ризики:
❌ Конфлікти імен між різними додатками  
❌ Проблеми безпеки - доступ з інших сесій  
❌ Складність контролю життєвого циклу  
❌ Потенційні витоки пам'яті при неправильному використанні  
❌ Неможливість використання в функціях  

### Коли використовувати:
- Координація між паралельними процесами
- Кешування даних для багатьох сесій
- Передача великих наборів даних між процедурами в різних сесіях
- Реалізація простих механізмів блокування

### Приклади використання:

**Координація між паралельними процесами:**
```sql
-- Процес координатор створює таблицю для відстеження статусу
CREATE TABLE ##ProcessStatus (
    ProcessID INT PRIMARY KEY,
    ProcessName VARCHAR(100) NOT NULL,
    Status VARCHAR(20) NOT NULL DEFAULT 'Starting',
    StartTime DATETIME2 NOT NULL DEFAULT SYSDATETIME(),
    EndTime DATETIME2 NULL,
    ErrorMessage NVARCHAR(MAX) NULL,
    
    INDEX IX_ProcessStatus_Status NONCLUSTERED (Status)
);

-- Ініціалізація процесів
INSERT INTO ##ProcessStatus (ProcessID, ProcessName)
VALUES 
    (1, 'DataImport'),
    (2, 'DataValidation'), 
    (3, 'DataTransformation'),
    (4, 'ReportGeneration');

-- В кожному паралельному процесі:
-- Процес 1 (імпорт даних)
UPDATE ##ProcessStatus 
SET Status = 'Running', StartTime = SYSDATETIME() 
WHERE ProcessID = 1;

-- ... виконання роботи ...

UPDATE ##ProcessStatus 
SET Status = 'Completed', EndTime = SYSDATETIME() 
WHERE ProcessID = 1;
```

**Кешування довідкових даних:**
```sql
-- Перевірка існування кешу
IF OBJECT_ID('tempdb..##ReferenceDataCache') IS NULL
BEGIN
    CREATE TABLE ##ReferenceDataCache (
        CacheKey VARCHAR(100) NOT NULL,
        CacheValue NVARCHAR(MAX) NOT NULL,
        ExpiryTime DATETIME2 NOT NULL,
        CreatedTime DATETIME2 NOT NULL DEFAULT SYSDATETIME(),
        
        PRIMARY KEY (CacheKey),
        INDEX IX_Cache_Expiry NONCLUSTERED (ExpiryTime)
    );
    
    -- Заповнення кешу
    INSERT INTO ##ReferenceDataCache (CacheKey, CacheValue, ExpiryTime)
    SELECT 
        'Country_' + CountryCode,
        CountryName,
        DATEADD(HOUR, 24, SYSDATETIME()) -- Кеш на 24 години
    FROM Countries WHERE IsActive = 1;
    
    INSERT INTO ##ReferenceDataCache (CacheKey, CacheValue, ExpiryTime)
    SELECT 
        'Currency_' + CurrencyCode,
        CurrencyName + ' (' + CurrencySymbol + ')',
        DATEADD(HOUR, 24, SYSDATETIME())
    FROM Currencies WHERE IsActive = 1;
END;

-- Використання кешу
DECLARE @CountryName NVARCHAR(MAX);
SELECT @CountryName = CacheValue 
FROM ##ReferenceDataCache 
WHERE CacheKey = 'Country_US' 
    AND ExpiryTime > SYSDATETIME();

-- Очищення застарілого кешу
DELETE FROM ##ReferenceDataCache 
WHERE ExpiryTime <= SYSDATETIME();
```

**Безпечний патерн створення з унікальними іменами:**
```sql
-- Створення унікального імені з timestamp та SPID
DECLARE @TableName SYSNAME = '##SharedData_' + 
    CAST(@@SPID AS VARCHAR(10)) + '_' + 
    FORMAT(SYSDATETIME(), 'yyyyMMddHHmmss');

DECLARE @SQL NVARCHAR(MAX) = 
    'CREATE TABLE ' + @TableName + ' (
        ID INT IDENTITY(1,1) PRIMARY KEY,
        SessionID INT NOT NULL DEFAULT @@SPID,
        Data NVARCHAR(MAX) NOT NULL,
        CreatedTime DATETIME2 NOT NULL DEFAULT SYSDATETIME()
    )';

EXEC sp_executesql @SQL;

-- Повідомлення іншим процесам про ім'я таблиці
-- (через файл, реєстр, базу даних тощо)
```

### Не втрачайте пильність

1. **Завжди перевіряйте існування** перед створенням:
```sql
IF OBJECT_ID('tempdb..##MyTable') IS NOT NULL
    DROP TABLE ##MyTable;
```

2. **Використовуйте унікальні імена** для уникнення конфліктів:
```sql
DECLARE @UniqueTableName SYSNAME = '##MyApp_' + CAST(@@SPID AS VARCHAR(10)) + '_' + CAST(NEWID() AS VARCHAR(36));
```

3. **Завжди очищайте** за собою:
```sql
-- В кінці процедури або в блоці TRY/CATCH
IF OBJECT_ID('tempdb..##MyTable') IS NOT NULL
    DROP TABLE ##MyTable;
```

---

## Порівняння

| Критерій | @table (Таблична змінна) | #table (Локальна) | ##table (Глобальна) |
|----------|-------------------------|-------------------|---------------------|
| **Обсяг даних** | Малі (до 1000 рядків) | Середні й великі (1000+) | Всі обсяги |
| **Швидкість** | ⚡⚡⚡ Найшвидша | ⚡⚡ Швидка | ⚡ Повільніша |
| **Область видимості** | Лише поточний batch | Лише поточна сесія | Всі сесії сервера |
| **Використання у функціях** | ✅ Єдиний дозволений | ❌ Заборонено | ❌ Заборонено |
| **Підтримка індексів** | ⚠️ Обмежено (PK, UNIQUE) | ✅ Повна підтримка | ✅ Повна підтримка |
| **Статистика** | ❌ Відсутня | ✅ Автоматична | ✅ Автоматична |
| **Навантаження на tempdb** | ✅ Мінімальне | ⚠️ Помірне | ⚠️ Помірне |
| **Паралельні плани** | ❌ Не підтримуються | ✅ Підтримуються | ✅ Підтримуються |
| **Ризик конфліктів** | ✅ Відсутній | ✅ Відсутній | ❌ Високий |
| **Складність управління** | ✅ Проста | ✅ Проста | ❌ Складна |

## Практичні рекомендації вибору

### Використовуйте @table коли:
- **Кількість рядків < 1000**
- **Прості операції SELECT, INSERT**
- **Всередині функцій** (обов'язково)
- **Швидка фільтрація** у складних запитах
- **Тимчасове зберігання параметрів**
- **При роботі з JSON та XML**

### Використовуйте #table коли:
- **Кількість рядків > 1000**
- **Потрібні індекси** для оптимізації
- **Складні JOIN операції** за участю цієї таблиці
- **Багаторазове звернення** до даних в межах однієї сесії
- **Потрібна статистика** для планів виконання

### Використовуйте ##table коли:
- **Необхідний обмін даними** між сесіями (показати тимчасові дані іншим користувачам)
- **Координація паралельних процесів**
- **Кешування даних** для багатьох підключень
- **Простий механізм блокування**

---

## Ресурси та посилання

**Офіційна документація Microsoft:**
- [CREATE TABLE (Transact-SQL)](https://docs.microsoft.com/en-us/sql/t-sql/statements/create-table-transact-sql)
- [Table Variable vs Temp Table](https://docs.microsoft.com/en-us/sql/t-sql/data-types/table-transact-sql)
- [tempdb Database](https://docs.microsoft.com/en-us/sql/relational-databases/databases/tempdb-database)

**Блоги:**
- [Brent Ozar: "Table Variables vs. Temp Tables"](https://www.brentozar.com/archive/2020/03/table-variables-vs-temp-tables/)
- [Paul White: "Temporary Object Performance"](https://sqlperformance.com/2019/08/sql-performance/temporary-object-performance)
- [Kimberly Tripp: "Table Variables and Temp Tables"](https://www.sqlskills.com/blogs/kimberly/)

---

