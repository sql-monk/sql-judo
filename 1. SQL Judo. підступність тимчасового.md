---
layout: default
title: "Підступність тимчасового"
---
![pitfalls](pitfalls.png)

# SQL Judo. Підступність тимчасового

> *«Той, хто креслить меч у тумані, ризикує поранити себе.»*


У світі SQL, такою підступністю є конструкція `SELECT INTO`. Вона приваблює своєю простотою, але приховує певні небезпеки.

## Основні проблеми SELECT INTO

**1. Автоматичне (неявне) визначення типів даних**
SQL Server автоматично визначає типи даних на основі вихідних даних, що може призвести до неочікуваних та неоптимальних типів.
- Тип даних визначається на основі першого рядка або найбільш "широкого" типу в наборі
- Для рядкових даних може бути обрано `NVARCHAR(MAX)` замість більш оптимального `VARCHAR(50)`
- Числові типи можуть бути перетворені на `DECIMAL` з максимальною точністю
- Дати можуть стати `DATETIME` замість більш ефективного `DATE`

**Докладніше:** [Data Type Precedence (Transact-SQL)](https://docs.microsoft.com/en-us/sql/t-sql/data-types/data-type-precedence-transact-sql)

**2. Блокування ресурсів та проблеми з tempdb**

Створеня таблиці в будья якій базі - [вимагає отримання блокування Schema Modification (Sch-M)](https://learn.microsoft.com/en-us/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide?view=sql-server-ver17#schema) 
(щоб, до прикладу, ніхто не видалив схему, чи не створив щось із таким же ім'ям, поки ваша [ТРАНЗАКЦІЯ](https://learn.microsoft.com/en-us/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide?view=sql-server-ver17#schema) не завершить роботу).  
Конструкція `SELECT ...INTO`  - [виконує дві операції в одній транзакції](https://learn.microsoft.com/en-us/sql/t-sql/queries/select-into-clause-transact-sql?view=sql-server-ver17#remarks) (_**Створення таблиці**_ і вставку в неї даних). 

Якщо Ви запустили `SELECT ...INTO`, а запит - скидую в тимчасову таблицю половину DWH - інші користувачі, котрі також в цей момент спробують виконати `SELECT ... INTO` - буду очікувати на завершення вашої транзакції)


**3. Відсутність індексів та статистики**
> Створена таблиця не має індексів, статистики або обмежень, що робить подальші запити неефективними.


[SELECT - INTO Clause (Transact-SQL)](https://learn.microsoft.com/sql/t-sql/queries/select-into-clause-transact-sql?view=sql-server-ver16)

[The Performance Trade-offs Between SELECT * INTO and SELECT THEN INSERT in T-SQL](https://thedbahub.com/the-performance-trade-offs-between-select-into-and-select-then-insert-in-t-sql/)

**Погано:**

```sql
SELECT 'No' + orderId, OrderDate INTO #Orders FROM dbo.Orders
```

**Добре:**

```sql
CREATE TABLE #Orders (
  OrderID varchar(50) PRIMARY KEY,
  OrderDate DATETIME,
  Amount DECIMAL(18,2)
)

INSERT INTO #Orders (OrderID, OrderDate, Amount)
SELECT CONCAT('No', orderId), OrderDate, Amount
FROM dbo.Orders
```

---

## Коли використання `SELECT INTO` доречне?

Хоч конструкція і підступна, проте є випадки, коли вона доречна:

* При швидкому аналізі або одноразових операціях для дебагу.
* Для оперативного копіювання структури й даних під час розробки чи дослідження.
* На малих наборах даних, де швидкодія не є критичною.

## SELECT TOP(0) ...INTO
Ще одним доречним варіантом є використання `SELECT TOP(0) ...INTO`, що дозволяє створити порожню таблицю з потрібною структурою, це дозволяє уникнути проблем з блокуваннями.

Типи даних можна явно вказати використовуючи `CAST` або `CONVERT` у запиті.
А індекси можна додати після створення таблиці.

```sql
SELECT TOP(0) 
  CONVERT(VARCHAR(50), CONCAT('No', orderId)), 
  OrderDate, 
  Amount
INTO #EmptyOrders
FROM dbo.Orders

INSERT INTO #Orders (OrderID, OrderDate, Amount)
SELECT CONCAT('No', orderId), OrderDate, Amount
FROM dbo.Orders
```

## Як просто отримати код для створення тимчасової таблиці

Щоб не помилитися у створенні таблиць, скористайтеся простими засобами:

* Використовуйте `sp_help`, щоб побачити структуру існуючої таблиці:

```sql
sp_help 'dbo.YourTable'
```

* Для отримання структури результатів запиту застосовуйте `sp_describe_first_result_set`:

```sql
EXECUTE sp_describe_first_result_set
    'SELECT object_id, name, type_desc FROM sys.indexes WHERE object_id = @id1',
    '@id1 int';
```
