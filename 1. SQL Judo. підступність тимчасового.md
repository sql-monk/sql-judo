---
layout: default
title: "Підступність тимчасового"
---

# SQL Judo. Підступність тимчасового

> *«Той, хто креслить меч у тумані, ризикує поранити себе.»*

У світі SQL, такою підступністю є конструкція `SELECT INTO`. Вона приваблює своєю простотою, але приховує певні небезпеки.

## Основні проблеми SELECT INTO

**1. Автоматичне (неявне) визначення типів даних**
> SQL Server автоматично визначає типи даних на основі вихідних даних, що може призвести до неочікуваних та неоптимальних типів.
> - Тип даних визначається на основі першого рядка або найбільш "широкого" типу в наборі
> - Для рядкових даних може бути обрано `NVARCHAR(MAX)` замість більш оптимального `VARCHAR(50)`
> - Числові типи можуть бути перетворені на `DECIMAL` з максимальною точністю
> - Дати можуть стати `DATETIME` замість більш ефективного `DATE`

**Докладніше:** [Data Type Precedence (Transact-SQL)](https://docs.microsoft.com/en-us/sql/t-sql/data-types/data-type-precedence-transact-sql)

**2. Блокування ресурсів та проблеми з tempdb**

> `SELECT ...INTO` створює ексклюзивні блокування на рівні схеми в tempdb та може блокувати інші операції.
Операція `SELECT ...INTO` отримує Schema Modification (Sch-M) блокування на tempdb. Внаслідок чого блокуватиме інші сесії, які намагаються створити тимчасові об'єкти


**3. Відсутність індексів та статистики**
> Створена таблиця не має індексів, статистики або обмежень, що робить подальші запити неефективними.


[SELECT - INTO Clause (Transact-SQL)](https://learn.microsoft.com/sql/t-sql/queries/select-into-clause-transact-sql?view=sql-server-ver16)

[The Performance Trade-offs Between SELECT * INTO and SELECT THEN INSERT in T-SQL](https://thedbahub.com/the-performance-trade-offs-between-select-into-and-select-then-insert-in-t-sql/)

**Погано:**

```sql
SELECT 'No' + orderId, OrderDate INTO #Orders FROM dbo.Orders
```

**Добре:**

```sql
CREATE TABLE #Orders (
  OrderID varchar(50) PRIMARY KEY,
  OrderDate DATETIME,
  Amount DECIMAL(18,2)
)

INSERT INTO #Orders (OrderID, OrderDate, Amount)
SELECT CONCAT('No', orderId), OrderDate, Amount
FROM dbo.Orders
```

---

## Коли використання `SELECT INTO` доречне?

Хоч конструкція і підступна, проте є випадки, коли вона доречна:

* При швидкому аналізі або одноразових операціях для дебагу.
* Для оперативного копіювання структури й даних під час розробки чи дослідження.
* На малих наборах даних, де швидкодія не є критичною.

## SELECT TOP(0) ...INTO
Ще одним доречним варіантом є використання `SELECT TOP(0) ...INTO`, що дозволяє створити порожню таблицю з потрібною структурою, це дозволяє уникнути проблем з блокуваннями.

> Типи даних можна явно вказати використовуючи `CAST` або `CONVERT` у запиті.
А індекси можна додати після створення таблиці.

```sql
SELECT TOP(0) 
  CONVERT(VARCHAR(50), CONCAT('No', orderId)), 
  OrderDate, 
  Amount
INTO #EmptyOrders
FROM dbo.Orders

INSERT INTO #Orders (OrderID, OrderDate, Amount)
SELECT CONCAT('No', orderId), OrderDate, Amount
FROM dbo.Orders
```

## Як просто отримати код для створення тимчасової таблиці

Щоб не помилитися у створенні таблиць, скористайтеся простими засобами:

* Використовуйте `sp_help`, щоб побачити структуру існуючої таблиці:

```sql
sp_help 'dbo.YourTable'
```

* Для отримання структури результатів запиту застосовуйте `sp_describe_first_result_set`:

```sql
EXECUTE sp_describe_first_result_set
    'SELECT object_id, name, type_desc FROM sys.indexes WHERE object_id = @id1',
    '@id1 int';
```