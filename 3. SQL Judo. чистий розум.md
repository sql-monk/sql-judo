---
layout: default
title: "Чистий розум"
---

# SQL Judo. Чистий розум — Про фільтрацію даних

> *«Чистий розум бачить суть, не заплутуючись у деталях.»*

Фільтрація даних — це мистецтво відсіювання зайвого, залишаючи лише те, що справді потрібно. Як майстер бойових мистецтв економить енергію на непотрібні рухи, так і SQL-майстер економить ресурси на непотрібні дані.

---

## Основи чистого мислення

### WHERE — перша лінія оборони

> *«Битва виграється не силою удару, а точністю попадання.»*

Найефективніша фільтрація відбувається якомога раніше у процесі виконання запиту. `WHERE` клаузула — ваш найважливіший інструмент для зменшення обсягу оброблюваних даних.

**Принципи ефективної фільтрації:**

1. **Найбільш селективні умови спочатку**
2. **Використання індексів**
3. **Уникнення функцій у WHERE**

```sql
-- Добре: селективна фільтрація спочатку
SELECT CustomerID, OrderDate, Amount
FROM Orders 
WHERE Status = 'Active'          -- високоселективна умова
  AND OrderDate >= '2024-01-01'  -- індексована колонка
  AND Amount > 1000               -- додаткова фільтрація
```

---

## Підступи розуму

### Антипатерни фільтрації

> *«Найнебезпечніший супротивник — той, якого ти не помічаєш.»*

**1. Функції в WHERE, що руйнують індекси**

```sql
-- ПОГАНО: функція YEAR() не дозволяє використовувати індекс
WHERE YEAR(OrderDate) = 2024

-- ДОБРЕ: діапазон дат використовує індекс
WHERE OrderDate >= '2024-01-01' 
  AND OrderDate < '2025-01-01'
```

**2. Неефективні текстові пошуки**

```sql
-- ПОГАНО: пошук з лівим wildcards не використовує індекс
WHERE ProductName LIKE '%Phone%'

-- ДОБРЕ: якщо можливо, пошук з початку рядка
WHERE ProductName LIKE 'iPhone%'

-- АЛЬТЕРНАТИВА: Full-Text Search для складних текстових пошуків
WHERE CONTAINS(ProductName, 'iPhone')
```

**3. Проблематичне використання OR**

```sql
-- ПОГАНО: OR може призвести до повного сканування таблиці
WHERE CategoryID = 1 OR CategoryID = 5 OR CategoryID = 10

-- ДОБРЕ: IN більш ефективний
WHERE CategoryID IN (1, 5, 10)

-- АБО: UNION ALL для різних типів умов
SELECT * FROM Products WHERE CategoryID = 1
UNION ALL
SELECT * FROM Products WHERE ProductName LIKE 'Special%'
```

```sql
-- ПОГАНО:
WHERE ReciveAccId <> 0 OR AccId <> 0

-- ДОБРЕ:
WHERE ReciveAccId + AccId > 0
```
### Підзапити vs JOIN 
> *«Не бійся використовувати силу, але знай, коли її застосовувати.»* 


---

## Інструменти чистого розуму

### EXISTS vs IN vs JOIN

> *«Різні шляхи ведуть до однієї мети, але не всі однаково швидкі.»*

**EXISTS — для перевірки існування**

```sql
-- Ефективно для великих таблиць
SELECT c.CustomerID, c.CustomerName
FROM Customers c
WHERE EXISTS (
    SELECT 1 
    FROM Orders o 
    WHERE o.CustomerID = c.CustomerID 
      AND o.OrderDate >= '2024-01-01'
);
```

**IN — для простих списків значень**

```sql
-- Добре для невеликих списків
SELECT * 
FROM Products 
WHERE CategoryID IN (1, 2, 3, 4, 5);
```

**JOIN — для отримання додаткових даних**

```sql
-- Коли потрібні дані з обох таблиць
SELECT c.CustomerName, COUNT(o.OrderID) as OrderCount
FROM Customers c
INNER JOIN Orders o ON c.CustomerID = o.CustomerID
WHERE o.OrderDate >= '2024-01-01'
GROUP BY c.CustomerID, c.CustomerName;
```

### NOT EXISTS vs NOT IN

**Важливо:** `NOT IN` може повернути неочікувані результати при наявності NULL значень!

```sql
-- НЕБЕЗПЕЧНО: якщо в підзапиті є NULL, результат буде порожній
SELECT CustomerID 
FROM Customers 
WHERE CustomerID NOT IN (
    SELECT CustomerID FROM Orders WHERE Status = 'Cancelled'
);

-- БЕЗПЕЧНО: EXISTS правильно обробляє NULL
SELECT c.CustomerID 
FROM Customers c
WHERE NOT EXISTS (
    SELECT 1 FROM Orders o 
    WHERE o.CustomerID = c.CustomerID 
      AND o.Status = 'Cancelled'
);
```

---

## Глибинна фільтрація

### CTE для поетапної фільтрації

> *«Складний шлях долається по кроках.»*

```sql
WITH ActiveCustomers AS (
    SELECT CustomerID, CustomerName
    FROM Customers 
    WHERE Status = 'Active'
      AND RegistrationDate >= '2020-01-01'
),
RecentOrders AS (
    SELECT CustomerID, COUNT(*) as OrderCount, SUM(Amount) as TotalAmount
    FROM Orders 
    WHERE OrderDate >= '2024-01-01'
    GROUP BY CustomerID
    HAVING COUNT(*) >= 5
)
SELECT 
    ac.CustomerID,
    ac.CustomerName,
    ro.OrderCount,
    ro.TotalAmount
FROM ActiveCustomers ac
INNER JOIN RecentOrders ro ON ac.CustomerID = ro.CustomerID
WHERE ro.TotalAmount > 10000;
```

### Filtered Indexes

Для часто використовуваних фільтрів створюйте відфільтровані індекси:

```sql
-- Індекс тільки для активних замовлень
CREATE INDEX IX_Orders_Active_Date 
ON Orders (OrderDate, Amount)
WHERE Status = 'Active';

-- Запит автоматично використає відфільтрований індекс
SELECT OrderID, Amount
FROM Orders 
WHERE Status = 'Active' 
  AND OrderDate >= '2024-06-01';
```

---

## Практичні кейси

### Кейс 1: Пошук клієнтів з останніми замовленнями

```sql
-- ПОГАНО: неефективний підзапит
SELECT CustomerID, CustomerName
FROM Customers c
WHERE (
    SELECT MAX(OrderDate) 
    FROM Orders o 
    WHERE o.CustomerID = c.CustomerID
) >= DATEADD(MONTH, -3, GETDATE());

-- ДОБРЕ: використання EXISTS
SELECT DISTINCT c.CustomerID, c.CustomerName
FROM Customers c
WHERE EXISTS (
    SELECT 1 
    FROM Orders o 
    WHERE o.CustomerID = c.CustomerID 
      AND o.OrderDate >= DATEADD(MONTH, -3, GETDATE())
);
```

### Кейс 2: Складна бізнес-логіка

```sql
-- Клієнти з високою активністю та лояльністю
WITH CustomerMetrics AS (
    SELECT 
        c.CustomerID,
        c.CustomerName,
        COUNT(o.OrderID) as OrderCount,
        SUM(o.Amount) as TotalSpent,
        MAX(o.OrderDate) as LastOrderDate,
        DATEDIFF(DAY, MIN(o.OrderDate), MAX(o.OrderDate)) as LoyaltyDays
    FROM Customers c
    INNER JOIN Orders o ON c.CustomerID = o.CustomerID
    WHERE c.Status = 'Active'
      AND o.Status IN ('Completed', 'Shipped')
    GROUP BY c.CustomerID, c.CustomerName
)
SELECT *
FROM CustomerMetrics
WHERE OrderCount >= 10
  AND TotalSpent >= 5000
  AND LastOrderDate >= DATEADD(MONTH, -6, GETDATE())
  AND LoyaltyDays >= 365;
```

---

## Коли чистота стає обтяжливою

### Баланс читабельності та продуктивності

> *«Досконалість — ворог хорошого.»*

Іноді складний, але читабельний запит краще за максимально оптимізований, але незрозумілий:

```sql
-- Читабельно, хоч і не ідеально оптимізовано
SELECT 
    p.ProductName,
    c.CategoryName,
    p.Price,
    p.Stock
FROM Products p
INNER JOIN Categories c ON p.CategoryID = c.CategoryID
WHERE p.Price BETWEEN @MinPrice AND @MaxPrice
  AND p.Stock > 0
  AND c.IsActive = 1
  AND (p.ProductName LIKE @SearchTerm + '%' OR @SearchTerm IS NULL);
```

### Динамічні фільтри

Для складних форм пошуку з опціональними параметрами:

```sql
SELECT p.ProductID, p.ProductName, p.Price
FROM Products p
WHERE (@CategoryID IS NULL OR p.CategoryID = @CategoryID)
  AND (@MinPrice IS NULL OR p.Price >= @MinPrice)
  AND (@MaxPrice IS NULL OR p.Price <= @MaxPrice)
  AND (@SearchTerm IS NULL OR p.ProductName LIKE '%' + @SearchTerm + '%')
  AND p.IsActive = 1;
```

---

## Висновок

> *«Чистий розум — не про досконалість коду, а про ясність намірів.»*

Ефективна фільтрація даних — це:

1. **Розуміння ваших даних** і їх розподілу
2. **Використання правильних індексів** для підтримки фільтрації
3. **Уникнення антипатернів** що руйнують продуктивність  
4. **Вибір правильного інструменту** для конкретної задачі
5. **Баланс між продуктивністю та читабельністю**

Пам'ятайте: найшвидший запит — той, який обробляє найменше даних. Фільтруйте рано, фільтруйте ефективно, фільтруйте розумно.

---

**Корисні посилання:**
- [Query Processing Architecture Guide](https://docs.microsoft.com/en-us/sql/relational-databases/query-processing-architecture-guide)
- [Indexes](https://docs.microsoft.com/en-us/sql/relational-databases/indexes/indexes)
- [Statistics](https://docs.microsoft.com/en-us/sql/relational-databases/statistics/statistics)
